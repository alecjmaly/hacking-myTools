assemble() {
    python3 /opt/hacking-myTools/tools/shellcoding/asm_helper.py -m asm $@
}

assemble86() {
    #!/bin/bash
    # compiles .nasm to binary
    base=`echo "$1" | sed 's/\.nasm$\|.asm$//g'`
    nasm -F dwarf -g -F dwarf -f elf32 -o "${base}".o "${1}"

    # link binary
    # if compiling on x64, add parameters in []
    # -N : make text section executable
    # -z execstack : make stack executable
    ld -m elf_i386 -z execstack -N -o "${base}" "${base}".o 


    rm "${base}".o
}

disassemble() {
    python3 /opt/hacking-myTools/tools/shellcoding/asm_helper.py -m disasm $@
}

dump-shellcode () {
    # alternative, better?..
    # objdump -d insertion_decode | grep -v "<" | grep -oP '[a-f0-9]{2} ' --color=never | tr -d '\n' | sed 's/ /\\x/g' | sed 's/\\x$//g' | sed 's/^/\\x/g' 
    objdump -d "$1" |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
    
    # get length
        accum=0;
    sentry="No nulls found";
    for i in $(objdump -d "${1}" -M intel | grep "^ " | cut -f 2);
    do
        # echo -n '\x'$i;
        accum=$(( accum + 1 ));
        if [[ "${i}" = "00" ]]; then
            sentry="You have nulls, try again";
        fi;
    done;
    echo && echo "length of shellcode: $accum";
    echo "${sentry}"
}
dump-shellcode tmp

string_to_push() {
    python3 /opt/hacking-myTools/tools/shellcoding/string_to_push.py $@
}

mts () {
    echo "assemble <assembly instructions|file>  -  quick assembly checker"
    echo "disassemble -i <shellcode|file>  -  quick disassembly checker"
    echo "assemble86 <file.asm|file.nasm>  -  assemble for x86"
    echo "dump-shellcode <ELF>"
    echo "string_to_push <string>  -  creates push statements with string reversed"
}